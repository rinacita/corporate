/*!
 * vue-thin-modal v1.3.0
 * https://github.com/ktsn/vue-thin-modal
 *
 * Copyright (c) 2017-present katashin
 * Released under the MIT license
 * https://github.com/ktsn/vue-thin-modal/blob/master/LICENSE
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function addStaticClass(data, staticClass) {
  if (!data.staticClass) {
    data.staticClass = staticClass;
  } else {
    data.staticClass += ' ' + staticClass;
  }
}

function assert(value, message) {
  if (!value) {
    throw new Error('[vue-thin-modal] ' + message);
  }
}

var Modal = {
  name: 'modal',

  props: {
    name: {
      type: String,
      required: true
    },
    disableBackdrop: Boolean,
    preMount: Boolean,
    backdropTransition: {
      type: [String, Object],
      default: function _default() {
        return { name: 'modal-backdrop' };
      }
    },
    contentTransition: {
      type: [String, Object],
      default: function _default() {
        return { name: 'modal-content' };
      }
    }
  },

  computed: {
    current: function current() {
      return this.$modal.currentName;
    },
    computedBackdropTransition: function computedBackdropTransition() {
      if (typeof this.contentTransition === 'string') {
        return { name: this.backdropTransition };
      }

      return this.backdropTransition;
    },
    computedContentTransition: function computedContentTransition() {
      if (typeof this.contentTransition === 'string') {
        return { name: this.contentTransition };
      }

      return this.contentTransition;
    },
    eventListners: function eventListners() {
      var _this = this;

      var events = ['before-open', 'opened', 'before-close', 'closed'];
      var listeners = {};
      events.forEach(function (event) {
        listeners[event] = function (name) {
          if (_this.name === name) {
            _this.$emit(event, name);
          }
        };
      });
      return listeners;
    }
  },

  mounted: function mounted() {
    var _this2 = this;

    var portal = this.$modal._getPortal();
    Object.keys(this.eventListners).forEach(function (event) {
      portal.$on(event, _this2.eventListners[event]);
    });

    portal.update.apply(portal, this._modalDataForPortal);
  },
  updated: function updated() {
    var portal = this.$modal._getPortal();
    portal.update.apply(portal, this._modalDataForPortal);
  },
  beforeDestroy: function beforeDestroy() {
    var _this3 = this;

    var portal = this.$modal._getPortal();

    portal.unregister(this.name);
    Object.keys(this.eventListners).forEach(function (event) {
      portal.$off(event, _this3.eventListners[event]);
    });
  },
  render: function render(h) {
    // Gather the data for sending portal in render function
    // so that rerendering will be triggered when dependencies are updated.
    this._modalDataForPortal = [this.name, {
      show: true,
      backdropTransition: this.computedBackdropTransition,
      contentTransition: this.computedContentTransition,
      disableBackdrop: this.disableBackdrop
    }, this.$slots];

    return this.preMount && this.current !== this.name ? h('div', {
      style: {
        display: 'none'
      }
    }, this.$slots.default) : h();
  }
};

var Backdrop = {
  functional: true,
  name: 'backdrop',

  props: {
    show: Boolean,
    backdropTransition: Object
  },

  render: function render(h, _ref) {
    var props = _ref.props,
        slots = _ref.slots;
    var show = props.show,
        backdropTransition = props.backdropTransition;


    var transitionData = {
      props: backdropTransition
    };

    return h('transition', transitionData, [show && (slots().default || h('div', { staticClass: 'modal-backdrop' }))]);
  }
};

var ModalContent = {
  functional: true,
  name: 'modal-content',

  props: {
    show: Boolean,
    disableBackdrop: Boolean,
    contentTransition: Object
  },

  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots;

    var listeners = data.on || {};
    var show = props.show,
        disableBackdrop = props.disableBackdrop,
        contentTransition = props.contentTransition;

    var child = ensureOnlyChild(slots().default || []);

    if (child) {
      addStaticClass(child.data, 'modal-content');
    }

    var transitionData = {
      props: contentTransition,
      on: listeners
    };

    return h('div', {
      staticClass: 'modal-content-wrapper',
      attrs: {
        role: 'dialog',
        'aria-hidden': String(!show)
      },
      on: {
        click: function click(event) {
          if (disableBackdrop) return;
          if (event.target !== event.currentTarget) return;

          if (listeners['click-backdrop']) {
            listeners['click-backdrop']();
          }
        }
      }
    }, [h('transition', transitionData, [show && child])]);
  }
};

function ensureOnlyChild(children) {
  var domChildren = children.filter(function (c) {
    return c.tag;
  });
  assert(domChildren.length <= 1, 'Modal must have only one child');
  return domChildren[0];
}

/* eslint-env browser */

var isBrowser = typeof window !== 'undefined';

function appendToBody(el) {
  if (isBrowser) {
    document.body.appendChild(el);
  }
}

function addBodyClass(className) {
  if (isBrowser) {
    document.body.classList.add(className);
  }
}

function removeBodyClass(className) {
  if (isBrowser) {
    document.body.classList.remove(className);
  }
}

function setBodyCss(name, value) {
  if (isBrowser) {
    var s = document.body.style;
    s[name] = value;
  }
}

function getScrollBarWidth() {
  if (!isBrowser) {
    return null;
  }
  return window.innerWidth - document.documentElement.offsetWidth;
}

function activeElement() {
  if (isBrowser) {
    return document.activeElement;
  }
}

function onReady(cb) {
  if (isBrowser) {
    document.addEventListener('DOMContentLoaded', cb);
  }
}

var openClassBody = 'modal-open';

var ModalPortal = {
  name: 'modal-portal',

  data: function data() {
    return {
      modals: {}
    };
  },


  computed: {
    prev: function prev() {
      return this.$modal.prevName;
    },
    current: function current() {
      return this.$modal.currentName;
    }
  },

  methods: {
    update: function update(name, props, slots) {
      var children = slots.default || [];

      // Inject key into children vnode
      children.forEach(function (child) {
        if (child.key) return;

        if (!child.data) {
          child.data = {};
        }
        child.key = child.data.key = name;
      });

      this.$set(this.modals, name, {
        props: props,
        children: children,
        backdrop: slots.backdrop
      });
    },
    unregister: function unregister(name) {
      this.$delete(this.modals, name);
    }
  },

  beforeCreate: function beforeCreate() {
    this.$modal._setPortal(this);
  },
  beforeMount: function beforeMount() {
    var _this = this;

    this.$on('click-backdrop', function () {
      _this.$modal.pop();
    });

    this.$on('before-open', function () {
      if (_this.current != null) {
        var padding = getScrollBarWidth();
        if (padding) {
          setBodyCss('paddingRight', padding + 'px');
        }
        addBodyClass(openClassBody);
      }
    });

    this.$on('closed', function () {
      if (_this.current == null) {
        setBodyCss('paddingRight', '');
        removeBodyClass(openClassBody);
      }
    });
  },
  render: function render(h) {
    var _this2 = this;

    var modal = this.modals[this.current];

    var events = {
      // Only react the first transition event.
      'before-enter': function beforeEnter() {
        return _this2.$emit('before-open', _this2.current);
      },
      'before-leave': function beforeLeave() {
        return _this2.$emit('before-close', _this2.prev);
      },

      // Need to wait until all transition element are completed
      'after-enter': function afterEnter() {
        return _this2.$emit('opened', _this2.current);
      },
      'after-leave': function afterLeave() {
        return _this2.$emit('closed', _this2.prev);
      },

      'click-backdrop': function clickBackdrop() {
        return _this2.$emit('click-backdrop');
      }
    };

    if (modal) {
      return createModalVNode(h, {
        props: modal.props,
        on: events
      }, modal.children, modal.backdrop);
    } else {
      return createModalVNode(h, { on: events }, []);
    }
  }
};

function createModalVNode(h, data, children, backdrop) {
  return h('div', { staticClass: 'modal-wrapper' }, [h(Backdrop, data, backdrop), h(ModalContent, data, children)]);
}

function generateMediator(Vue) {
  var state = {
    portal: null
  };

  return new Vue({
    // Mark this Vue instance is a mediator to avoid infinite loop
    // by trying to create another mediator in the beforeCreate hook in this mediator.
    vueThinModalMediator: true,

    data: {
      stack: [],
      prevName: null
    },

    computed: {
      currentName: function currentName() {
        var stack = this.stack;
        var modal = stack[stack.length - 1];
        return modal && modal.name;
      }
    },

    methods: {
      push: function push(name) {
        var focusedElement = activeElement();
        if (focusedElement) {
          focusedElement.blur();
        }

        var item = {
          name: name,
          focusedElement: focusedElement

          // Prevent to make reactive
        };Object.freeze(item);

        this.stack.push(item);
      },
      pop: function pop() {
        var item = this.stack.pop();
        if (item && item.focusedElement) {
          item.focusedElement.focus();
        }
      },
      replace: function replace(name) {
        this.pop();
        this.push(name);
      },
      _setPortal: function _setPortal(portal) {
        state.portal = portal;
      },
      _getPortal: function _getPortal() {
        assert(state.portal, 'You need to put <modal-portal> or set `autoMountPortal: true` plugin option.');
        return state.portal;
      }
    },

    watch: {
      currentName: function currentName(_, prevName) {
        this.prevName = prevName;
      }
    }
  });
}

var Vue = void 0;

function install(_Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert(Vue !== _Vue, 'Already installed');

  Vue = _Vue;

  var descriptor = {
    get: function get() {
      return this.$root.$_vueThinModal;
    }
  };

  Object.defineProperty(Vue.prototype, '$modal', descriptor);

  Vue.component('modal', Modal);
  Vue.component('modal-portal', ModalPortal);

  if (options.autoMountPortal !== false) {
    // If the portal is auto mounted, should share singleton mediator
    // because the root instance of the portal component is different with the app one.
    // Note that auto mount will not be used on SSR environment.
    Vue.prototype.$_vueThinModal = generateMediator(Vue);

    // Mount portal component under the body element.
    var ModalPortalCtor = Vue.extend(ModalPortal);
    var portal = new ModalPortalCtor();

    onReady(function () {
      portal.$mount();
      appendToBody(portal.$el);
    });
  } else {
    // If the portal will be manually mounted, generate the medator for each root instance.
    // Then we can handle SSR environment which may create multiple instances of portal among each sessions.
    Vue.mixin({
      beforeCreate: function beforeCreate() {
        if (!this.$parent && !this.$options.vueThinModalMediator) {
          this.$_vueThinModal = generateMediator(Vue);
        }
      }
    });
  }
}

var index = {
  install: install
};

exports.Modal = Modal;
exports.ModalPortal = ModalPortal;
exports.generateMediator = generateMediator;
exports.default = index;
